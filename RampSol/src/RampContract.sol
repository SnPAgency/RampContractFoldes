// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.30;
/**
 * @title RampContract
 * @dev This contract is a placeholder for the Ramp protocol implementation.
 * It will include functions and state variables related to the Ramp protocol.
 * The Ramp protocol is designed to facilitate the exchange of assets in a decentralized manner.
 * This contract will be expanded in future iterations to include the full functionality of the Ramp protocol.
 * The Ramp protocol aims to provide a secure and efficient way to exchange assets with minimal reliance on
 * centralized intermediaries.
 */

import {PausableUpgradeable} from "@openzeppelin-contracts-upgradeable/utils/PausableUpgradeable.sol";
import {ReentrancyGuardTransientUpgradeable} from "@openzeppelin-contracts-upgradeable/utils/ReentrancyGuardTransientUpgradeable.sol";
import {Initializable} from "@openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol";
import {OwnableUpgradeable} from "@openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol";
import {Math} from "@openzeppelin-contracts/utils/math/Math.sol";
import {IERC20} from "@openzeppelin-contracts/token/ERC20/IERC20.sol";
import {IERC20Permit} from "@openzeppelin-contracts/token/ERC20/extensions/IERC20Permit.sol";
import {IRampContract} from "./IRampContract.sol";
import {Errors} from "./helpers/errors.sol";

contract RampContract is
    Initializable,
    PausableUpgradeable,
    OwnableUpgradeable,
    ReentrancyGuardTransientUpgradeable
{

    /**
     * @dev Libraries
     */
    using Math for uint256;
    
    /**
     * @dev State Variables
     */

    // Allowed Assets
    mapping(address => bool) private _allowedAssets;

    // List of allowed assets
    // This is a dynamic array that holds the addresses of all allowed assets.
    // It is used to keep track of the assets that are allowed for deposits and withdrawals.
    address[] private _allowedAssetsList;

    // Project Revenue per Asset
    // This mapping keeps track of the revenue generated by each asset for the project.
    // and the percentage of the fee charged for each transaction.
    mapping(address => IRampContract.AssetInfo) public assetInfo;

    // Vault Address
    // This is the address of the vault where the project revenue is stored.
    address payable public vault;

    /**
     * @dev Functions
     */

    /**
     * @dev Initializes the contract.
     */
    function initialize(address _controller, address payable _vault) public initializer {
        __Pausable_init();
        __Ownable_init(_controller);
        vault = _vault;
        _allowedAssets[address(0)] = true;
        _allowedAssetsList.push(address(0));
        assetInfo[address(0)] = IRampContract.AssetInfo(1, 0);
    }

    /**
     * @dev Pause function.
     * This function is used to pause the contract, preventing any state changes.
     * Only the Controller can call this function.
     */
    function pause() external onlyOwner {
        _pause();
    }
    /**
     * @dev Unpause function.
     * This function is used to unpause the contract, allowing state changes again.
     * Only the Controller can call this function.
     */

    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev function fundContractWithEth()
     * @dev Funds the contract with ETH.
     * @notice msg.value is the amount of ETH to be sent to the contract.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function emits the EthReceived event to indicate that the ETH has been received.
     */
    function fundContractWithEth() external payable onlyOwner whenNotPaused nonReentrant {
        if (msg.value <= 0) {
            revert Errors.Invalid__EthValue(msg.value);
        }
        payable(address(this)).transfer(msg.value);
        emit IRampContract.EthReceived(msg.sender, msg.value);
    }

    /**
     * @dev function addAllowedAsset(address, address, uint256)
     * @dev Add an asset to the allowed assets list.
     * @param asset The address of the asset to be added.
     * @param funder The address of the intiall balancefunder.
     * @param _feePercentage The fee percentage for the asset.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function also transfers funds to the contract
     * @notice This function emits the AssetAllowedAdded event to indicate that the asset has been added.
     */
    function addAllowedAsset(
        address asset,
        address funder,
        uint256 _feePercentage
    ) external onlyOwner whenNotPaused {
        // Ensure the asset address is valid and not already allowed
        if (asset == address(0)) {
            revert Errors.Asset__InvalidAddress(asset);
        }

        // ensure the fee is valid
        if (_feePercentage <= 0 || _feePercentage > 5) {
            revert Errors.Invalid__FeePercentage(_feePercentage);
        }

        // Check if the asset is already allowed
        if (!_allowedAssets[asset]) {
            uint256 initialBalance = IERC20(asset).allowance(funder, address(this));

            // Fund the contract with the amount allowed by the funder
            if (initialBalance > 0) {
                bool success = IERC20(asset).transferFrom(funder, address(this), initialBalance);
                if (!success) {
                    revert Errors.Asset__TransferFailed(asset, funder);
                }
            }

            _allowedAssets[asset] = true;
            assetInfo[asset] = IRampContract.AssetInfo(_feePercentage, 0);
            _allowedAssetsList.push(asset);
            // Emit an event to indicate that the asset has been added
            emit IRampContract.AssetAllowedAdded(asset, funder, _feePercentage, initialBalance);
        } else {
            // If the asset is already allowed, revert the transaction
            revert Errors.Asset__AlreadyAllowed(asset);
        }
    }

    /**
     * @dev function removeAllowedAsset(address, address)
     * @dev Remove an asset from the allowed assets list.
     * @param asset The address of the asset to be removed.
     * @param balanceRecipient The address of the recipient of the asset balance.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function transfers the balance of the asset to the balanceRecipient.
     * @notice This function emits the AssetAllowedRemoved event to indicate that the asset has been removed.
     */
    function removeAllowedAsset(address asset, address balanceRecipient) external onlyOwner whenNotPaused {
        // Ensure the asset address is valid
        if (asset == address(0)) {
            revert Errors.Asset__InvalidAddress(asset);
        }

        // Check if the asset is allowed
        if (_allowedAssets[asset]) {
            assetInfo[asset] = IRampContract.AssetInfo(0, 0);
            // Remove the asset from the allowed assets list
            for (uint256 i = 0; i < _allowedAssetsList.length; i++) {
                if (_allowedAssetsList[i] == asset) {
                    _allowedAssets[asset] = false;
                    // Move the last element to the current position and pop the last element
                    _allowedAssetsList[i] = _allowedAssetsList[_allowedAssetsList.length - 1];
                    _allowedAssetsList.pop();
                    break;
                }
            }
            // transfer the balance of the asset to the balanceRecipient
            uint256 balance = IERC20(asset).balanceOf(address(this));
            if (balance > 0) {
                bool success = IERC20(asset).transfer(balanceRecipient, balance);
                if (!success) {
                    revert Errors.Asset__TransferFailed(asset, balanceRecipient);
                }
            }
            emit IRampContract.AssetAllowedRemoved(asset, balanceRecipient, balance);
        } else {
            // If the asset is not allowed, revert the transaction
            revert Errors.Asset__NotPresent(asset);
        }
    }

    /**
     * @dev function onRampDeposit(address, uint256, address, OnrampMedium, Region, bytes)
     * @dev Deposit function for the Ramp protocol.
     * @param asset The address of the asset to be deposited.
     * @param amount The amount of the asset to be deposited.
     * @param sender The address of the sender.
     * @param medium The medium of the deposit.
     * @param region The region of the deposit.
     * @param data The data of the deposit.
     * @notice This function can only be called when the contract is not paused.
     * @notice This function transfers the amount of the asset from the sender to the contract.
     * @notice This function emits the RampDeposit event to indicate that the asset amount
     * has been deposited from the user to the contract.
     */
    function onRampDeposit(
        address asset,
        uint256 amount,
        address sender,
        IRampContract.OnrampMedium medium,
        IRampContract.Region region,
        bytes memory data
    ) external whenNotPaused nonReentrant {
        // Placeholder for deposit logic
        if (!_allowedAssets[asset]) {
            revert Errors.Asset__InvalidAddress(asset);
        }

        IERC20 token = IERC20(asset);
        IRampContract.AssetInfo storage _assetInfo = assetInfo[asset];


        //transfer the amount of the asset from the sender to the contract
        bool retValue = token.transferFrom(sender, address(this), amount);

        if (retValue) {

            uint256 fee = Math.mulDiv(_assetInfo.feePercentage, amount, 100);

            (bool addSuccess, uint256 newRevenue) = Math.tryAdd(_assetInfo.revenuePerAsset, fee);
            if (!addSuccess) {
                revert Errors.Math__AdditionError(_assetInfo.revenuePerAsset, fee);
            }
            _assetInfo.revenuePerAsset = newRevenue;

            uint256 amountAfterFee = amount - fee;

            emit IRampContract.RampDeposit(asset, sender, amountAfterFee, medium, region, data);
        }
    }

    /**
     * @dev function onRampDepositNative(OnrampMedium, Region, bytes)
     * @dev Deposits Native token.
     * @param medium The medium of the onramp.
     * @param region The region of the onramp.
     * @param data The data of the onramp.
     * @notice this function is payable. The amount of the asset is the amount of the native token sent.
     * @notice This function can only be called when the contract is not paused.
     * @notice This function transfers the amount of the asset from the sender to the contract.
     * @notice This function emits the RampDeposit event to indicate that the asset amount
     * has been deposited from the user to the contract.
     */
    function onRampNative(
        IRampContract.OnrampMedium medium,
        IRampContract.Region region,
        bytes memory data
    ) external payable whenNotPaused nonReentrant {
        // Placeholder for deposit logic
        IRampContract.AssetInfo memory _assetInfo = assetInfo[address(0)];

        //transfer the amount of the asset from the sender to the contract

        if (msg.value > 0) {

            (uint256 fee, uint256 amountAfterFee) = amountAfterFees(_assetInfo.feePercentage, msg.value);
            (bool addSuccess, uint256 newRevenue) = Math.tryAdd(_assetInfo.revenuePerAsset, fee);
            if (!addSuccess) {
                revert Errors.Math__AdditionError(_assetInfo.revenuePerAsset, fee);
            }
            _assetInfo.revenuePerAsset = newRevenue;

            emit IRampContract.RampDeposit(address(0), msg.sender, amountAfterFee, medium, region, data);
        }
    }

    /**
     * @dev function onRampERC20(address, uint256, address, OnrampMedium, Region, bytes)
     * @dev Deposit  for ERC20 tokens.
     * @param asset The address of the asset to be deposited.
     * @param amount The amount of the asset to be deposited.
     * @param sender The address of the sender.
     * @param permitParams The permit parameters.
     * @param medium The medium of the deposit.
     * @param region The region of the deposit.
     * @param data The data of the deposit.
     * @notice This function can only be called when the contract is not paused.
     * @notice This function transfers the amount of the asset from the sender to the contract.
     * @notice This function emits the RampDeposit event to indicate that the asset amount
     * has been deposited from the user to the contract.
     */
    function onRampWithPermit(
        address asset,
        uint256 amount,
        address sender,
        IRampContract.PermitParams memory permitParams,
        IRampContract.OnrampMedium medium,
        IRampContract.Region region,
        bytes memory data
    ) external whenNotPaused {

        if (!_allowedAssets[asset]) {
            revert Errors.Asset__InvalidAddress(asset);
        }

        IERC20Permit token = IERC20Permit(asset);

        token.permit(sender, address(this), amount, permitParams.deadline, permitParams.v, permitParams.r, permitParams.s);

        // Step 2: Transfer tokens
        bool transferSuccess = IERC20(asset).transferFrom(sender, address(this), amount);

        if (transferSuccess) {
            IRampContract.AssetInfo memory _assetInfo = assetInfo[asset];
            (uint256 fee, uint256 amountAfterFee) = amountAfterFees(_assetInfo.feePercentage, amount);

            (bool addSuccess, uint256 newRevenue) = Math.tryAdd(_assetInfo.revenuePerAsset, fee);
            if (!addSuccess) {
                revert Errors.Math__AdditionError(_assetInfo.revenuePerAsset, fee);
            }
            _assetInfo.revenuePerAsset = newRevenue;

            emit IRampContract.RampDeposit(asset, sender, amountAfterFee, medium, region, data);
        }

        else {
            revert Errors.Asset__TransferFailed(asset, sender);
        }
    }

    /**
     * @dev function withdraw(address, uint256, address)
     * @dev Withdraw function for the Ramp protocol.
     * @param asset The address of the asset to be withdrawn.
     * @param amount The amount of the asset to be withdrawn.
     * @param recipient The address of the recipient.
     * @notice This function can only be called when the contract is not paused.
     * @notice This function transfers the amount of the asset from the contract to the recipient.
     * @notice This function emits the RampWithdraw event to indicate that the asset 
     * amount has been sent to the user.
     * @notice This function does not update the revenue per asset for the asset since this gets computed offchain.
     */
    function offRampWithdraw(
        address asset,
        uint256 amount,
        address recipient
    ) external whenNotPaused onlyOwner {
        // Placeholder for withdrawal logic
        if (!_allowedAssets[asset]) {
            revert Errors.Asset__InvalidAddress(asset);
        }
        IERC20 token = IERC20(asset);

        IRampContract.AssetInfo memory _assetInfo = assetInfo[asset];

        if ((token.balanceOf(address(this)) - _assetInfo.revenuePerAsset) < amount) {
            revert Errors.Invalid__AssetBalance(asset, address(this));
        }


        bool retValue = token.transfer(recipient, amount);

        if (retValue) {
            emit IRampContract.RampWithdraw(asset, recipient, amount);
        }
    }


    /**
     * @dev function offRampNative(address payable receiver, uint256 amount)
     * @dev Withdraws native tokens from the contract.
     * @param receiver The address of the receiver.
     * @param amount The amount of native tokens to be withdrawn.
     * @notice This function can only be called by the owner when the contract is not paused.
     * @notice This function transfers the amount of native tokens from the contract to the receiver.
     * @notice This function emits the RampWithdraw event to indicate that the native tokens amount
     * has been sent to the user.
     * @notice This function does not update the revenue per asset for the asset since this gets computed offchain.
     */
    function offRampNative(address payable receiver, uint256 amount) external whenNotPaused onlyOwner {
        IRampContract.AssetInfo memory _assetInfo = assetInfo[address(0)];

        if ((address(this).balance - _assetInfo.revenuePerAsset) < amount) {
            revert Errors.Invalid__AssetBalance(address(0), address(this));
        }
        receiver.transfer(amount);
        emit IRampContract.RampWithdraw(address(0), receiver, amount);
    }
        

    /**
     * @dev function withdrawEtherRevenue(uint256 amount) 
     * @dev withdraws Ether from the contract.
     * @param amount The amount of Ether to be withdrawn.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function transfers the amount of Ether from the contract to the vault.
     * @notice This function emits the EthWithdrawn event to indicate that the eth balance in 
     * the contract has been withdrawn.
     */
    function withdrawEtherRevenue(uint256 amount) external onlyOwner {
        // Placeholder for withdrawing Ether
        // This function can be used to withdraw Ether from the contract.
        // It can be used for funding the project or for other purposes.
        require(address(this).balance >= amount, "Insufficient balance");
        vault.transfer(amount);
        emit IRampContract.EthWithdrawn(vault, amount);
    }

    /**
     * @dev function withdraAssetRevenue(address asset) 
     * @dev withdraws asset revenue from the contract.
     * @param asset The address of the asset to be withdrawn.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function transfers the amount of the asset from the contract to the vault.
     * @notice This function emits the AssetRevenueWithdrawn event to indicate that the asset balance in 
     * the contract has been withdrawn.
     */
    function withdraAssetRevenue(address asset) external onlyOwner {
        if (!_allowedAssets[asset]) {
            revert Errors.Asset__InvalidAddress(asset);
        }
        IERC20 token = IERC20(asset);
        uint256 amount = assetInfo[asset].revenuePerAsset;
        bool retValue = token.transfer(vault, amount);
        if (retValue) {
            assetInfo[asset].revenuePerAsset = 0;
            emit IRampContract.AssetRevenueWithdrawn(asset, amount);
        }
        else {
            revert Errors.Revenue__WithdrawFailed(asset);
        }
    }

    /**
     * @dev function setNewVault(address payable) 
     * @dev sets a new vault address.
     * @param _vault The address of the new vault.
     * @notice This function can only be called by the owner of the contract.
     */
    function setNewVault(address payable _vault) external onlyOwner {
        // Ensure the vault address is valid and not the zero address or the current vault
        if (_vault == address(0) || _vault == vault) {
            revert Errors.Invalid__VaultAddress(_vault);
        }
        // Set the vault address where the project revenue is stored
        vault = _vault;
        emit IRampContract.VaultChanged(vault, _vault);
    }

    /**
     * @dev function setNewFeePercentage(address, uint256)
     * @dev sets a new fee percentage for an asset.
     * @param asset The address of the asset.
     * @param feePercentage The new fee percentage.
     * @notice This function can only be called by the owner of the contract.
     */
    function setNewFeePercentage(address asset, uint256 feePercentage) external onlyOwner {
        assetInfo[asset].feePercentage = feePercentage;
    }

    /**
     * @dev receive function to receive Ether.
     * This function is used to receive Ether sent to the contract.
     */
    receive() external payable {
        // Placeholder for receiving Ether
        // This function can be used to receive Ether directly into the contract.
        // It can be used for funding the contract or for other purposes.
        emit IRampContract.EthReceived(msg.sender, msg.value);
    }


    /**
     * @dev function isAssetAllowed(address) 
     * @dev checks if an asset is allowed.
     * @param asset The address of the asset to be checked.
     * @return bool Returns true if the asset is allowed, false otherwise.
     */
    function isAssetAllowed(address asset) external view returns (bool) {
        return _allowedAssets[asset];
    }

    /**
     * @dev function getAllowedAssets() 
     * @dev gets the list of allowed assets.
     * @return address[] Returns an array of addresses of allowed assets.
     */
    function getAllowedAssets() external view returns (address[] memory) {
        return _allowedAssetsList;
    }

    /**
     * @dev function getAssetInfo(address) 
     * @dev gets the info of an asset.
     * @param asset The address of the asset to be checked.
     * @return AssetInfo Returns the info of the asset.
     */
    function getAssetInfo(address asset) external view returns (IRampContract.AssetInfo memory) {
        return assetInfo[asset];
    }

    /**
     * @dev function getAssetFeePercentage(address) 
     * @dev gets the fee percentage of an asset.
     * @param asset The address of the asset to be checked.
     * @return uint256 Returns the fee percentage of the asset.
     */
    function getAssetFeePercentage(address asset) external view returns (uint256) {
        return assetInfo[asset].feePercentage;
    }

    /**
     * @dev function getAssetRevenue(address) 
     * @dev gets the revenue of an asset.
     * @param asset The address of the asset to be checked.
     * @return uint256 Returns the revenue of the asset.
     */
    function getAssetRevenue(address asset) external view returns (uint256) {
        return assetInfo[asset].revenuePerAsset;
    }

    function amountAfterFees(uint256 feePercentage, uint256 amount) public pure returns (uint256 fee, uint256 amountAfterFee) {
        fee = Math.mulDiv(feePercentage, amount, 100);
        amountAfterFee = amount - fee;
        return (fee, amountAfterFee);
    }
}