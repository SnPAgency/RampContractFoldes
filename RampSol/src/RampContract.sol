// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.30;
/**
 * @title RampContract
 * @dev This contract is a placeholder for the Ramp protocol implementation.
 * It will include functions and state variables related to the Ramp protocol.
 * The Ramp protocol is designed to facilitate the exchange of assets in a decentralized manner.
 * This contract will be expanded in future iterations to include the full functionality of the Ramp protocol.
 * The Ramp protocol aims to provide a secure and efficient way to exchange assets with minimal reliance on
 * centralized intermediaries.
 */

import {PausableUpgradeable} from "@openzeppelin/utils/PausableUpgradeable.sol";
import {Initializable} from "@openzeppelin/proxy/utils/Initializable.sol";
import {OwnableUpgradeable} from "@openzeppelin/access/OwnableUpgradeable.sol";
import {IERC20} from "@openzeppelin-contracts/token/ERC20/IERC20.sol";

contract RampContract is Initializable, PausableUpgradeable, OwnableUpgradeable {
    /**
     * @dev Errors
     */
    error Asset__AlreadyAllowed(address asset);
    error Asset__NotPresent(address asset);
    error Asset__InvalidAddress(address asset);
    error Invalid__VaultAddress(address vault);
    error Invalid__FeePercentage(uint256 feePercentage);

    /**
     * @dev State Variables
     */

    // Allowed Assets
    mapping(address => bool) private _allowedAssets;

    // List of allowed assets
    // This is a dynamic array that holds the addresses of all allowed assets.
    // It is used to keep track of the assets that are allowed for deposits and withdrawals.
    address[] private _allowedAssetsList;

    // Project Revenue per Asset
    // This mapping keeps track of the revenue generated by each asset for the project.
    mapping(address => uint256) public projectRevenuePerAsset;

    // Vault Address
    // This is the address of the vault where the project revenue is stored.
    address payable public vault;

    // Fee Percentage
    // This variable holds the percentage of the fee charged for each transaction.
    mapping(address => uint256) public assetFeePercentage;

    /**
     * @dev Events
     */

    // Event emitted when an asset is added to the allowed assets list
    event AssetAllowedAdded(
        address indexed asset,
        uint256 initialFeePercentage,
        uint256 initialBalance,
        address indexed funder
    );

    // Event emitted when an asset is removed from the allowed assets list
    event AssetAllowedRemoved(
        address indexed asset,
        address indexed balanceRecipient,
        uint256 balance
    );

    // Event emitted when a deposit is made to the Ramp protocol
    event RampDeposit(address indexed asset, uint256 amount, address indexed sender);

    // Event emitted when a withdrawal is made from the Ramp protocol
    event RampWithdraw(address indexed asset, uint256 amount, address indexed recipient);

    // Event emitted when Ether is withdrawn from the contract
    event EthWithdrawn(uint256 amount, address indexed recipient);

    // Event emitted when the vault address is changed
    event VaultChanged(address indexed oldVault, address indexed newVault);

    /**
     * @dev Functions
     */

    /**
     * @dev Initializes the contract.
     */
    function initialize(address _controller, address payable _vault) public initializer {
        __Pausable_init();
        __Ownable_init(_controller);
        vault = _vault;
    }

    /**
     * @dev Pause function.
     * This function is used to pause the contract, preventing any state changes.
     * Only the Controller can call this function.
     */
    function pause() external onlyOwner {
        _pause();
    }
    /**
     * @dev Unpause function.
     * This function is used to unpause the contract, allowing state changes again.
     * Only the Controller can call this function.
     */

    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @dev Add an asset to the allowed assets list.
     * @param asset The address of the asset to be added.
     * @param funder The address of the intiall balancefunder.
     * @param _feePercentage The fee percentage for the asset.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function also transfers funds to the contract
     * @notice This function emits the AssetAllowedAdded event to indicate that the asset has been added.
     */
    function addAllowedAsset(
        address asset,
        address funder,
        uint256 _feePercentage
    ) external onlyOwner {
        // Ensure the asset address is valid and not already allowed
        if (asset == address(0)) {
            revert Asset__InvalidAddress(asset);
        }

        // ensure the fee is valid
        if (_feePercentage <= 0 || _feePercentage > 5) {
            revert Invalid__FeePercentage(_feePercentage);
        }

        // Check if the asset is already allowed
        if (!_allowedAssets[asset]) {
            uint256 initialBalance = IERC20(asset).allowance(funder, address(this));

            // Fund the contract with the amount allowed by the funder
            if (initialBalance > 0) {
                IERC20(asset).transferFrom(funder, address(this), initialBalance);
            }

            _allowedAssets[asset] = true;
            assetFeePercentage[asset] = _feePercentage;
            _allowedAssetsList.push(asset);
            // Emit an event to indicate that the asset has been added
            emit AssetAllowedAdded(asset, _feePercentage, initialBalance, funder);
        } else {
            // If the asset is already allowed, revert the transaction
            revert Asset__AlreadyAllowed(asset);
        }
    }

    /**
     * @dev Remove an asset from the allowed assets list.
     * @param asset The address of the asset to be removed.
     * @param balanceRecipient The address of the recipient of the asset balance.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function transfers the balance of the asset to the balanceRecipient.
     * @notice This function emits the AssetAllowedRemoved event to indicate that the asset has been removed.
     */
    function removeAllowedAsset(address asset, address balanceRecipient) external onlyOwner {
        // Ensure the asset address is valid
        if (asset == address(0)) {
            revert Asset__InvalidAddress(asset);
        }

        // Check if the asset is allowed
        if (_allowedAssets[asset]) {
            assetFeePercentage[asset] = 0;
            // Remove the asset from the allowed assets list
            for (uint256 i = 0; i < _allowedAssetsList.length; i++) {
                if (_allowedAssetsList[i] == asset) {
                    _allowedAssets[asset] = false;
                    // Move the last element to the current position and pop the last element
                    _allowedAssetsList[i] = _allowedAssetsList[_allowedAssetsList.length - 1];
                    _allowedAssetsList.pop();
                    break;
                }
            }
            // transfer the balance of the asset to the balanceRecipient
            uint256 balance = IERC20(asset).balanceOf(address(this));
            if (balance > 0) {
                IERC20(asset).transfer(balanceRecipient, balance);
            }
            emit AssetAllowedRemoved(asset, balanceRecipient, balance);
        } else {
            // If the asset is not allowed, revert the transaction
            revert Asset__NotPresent(asset);
        }
    }

    /**
     * @dev Deposit function for the Ramp protocol.
     * @param asset The address of the asset to be deposited.
     * @param amount The amount of the asset to be deposited.
     * @param sender The address of the sender.
     * @notice This function can only be called when the contract is not paused.
     * @notice This function transfers the amount of the asset from the sender to the contract.
     * @notice This function emits the RampDeposit event to indicate that the asset amount
     * has been deposited from the user to the contract.
     */
    function onRampDeposit(address asset, uint256 amount, address sender) external whenNotPaused {
        // Placeholder for deposit logic
        if (!_allowedAssets[asset]) {
            revert Asset__InvalidAddress(asset);
        }

        bool retValue = IERC20(asset).transferFrom(sender, address(this), amount);

        if (retValue) {
            emit RampDeposit(asset, amount, sender);
        }
    }

    /**
     * @dev Withdraw function for the Ramp protocol.
     * @param asset The address of the asset to be withdrawn.
     * @param amount The amount of the asset to be withdrawn.
     * @param recipient The address of the recipient.
     * @notice This function can only be called when the contract is not paused.
     * @notice This function transfers the amount of the asset from the contract to the recipient.
     * @notice This function emits the RampWithdraw event to indicate that the asset 
     * amount has been sent to the user.
     */
    function offRampWithdraw(address asset, uint256 amount, address recipient) external whenNotPaused onlyOwner {
        // Placeholder for withdrawal logic
        if (!_allowedAssets[asset]) {
            revert Asset__InvalidAddress(asset);
        }

        bool retValue = IERC20(asset).transfer(recipient, amount);

        if (retValue) {
            emit RampWithdraw(asset, amount, recipient);
        }
    }

    /**
     * @dev Function to withdraw Ether from the contract.
     * @param amount The amount of Ether to be withdrawn.
     * @notice This function can only be called by the owner of the contract.
     * @notice This function transfers the amount of Ether from the contract to the vault.
     * @notice This function emits the EthWithdrawn event to indicate that the eth balance in 
     * the contract has been withdrawn.
     */
    function withdrawEtherRevenue(uint256 amount) external onlyOwner {
        // Placeholder for withdrawing Ether
        // This function can be used to withdraw Ether from the contract.
        // It can be used for funding the project or for other purposes.
        require(address(this).balance >= amount, "Insufficient balance");
        vault.transfer(amount);
        emit EthWithdrawn(amount, vault);
    }

    /**
     * @dev Fallback function to receive Ether.
     * This function is used to receive Ether sent to the contract.
     */
    receive() external payable {
        // Placeholder for receiving Ether
        // This function can be used to receive Ether directly into the contract.
        // It can be used for funding the contract or for other purposes.
        emit RampDeposit(address(0), msg.value, msg.sender);
    }

    /**
     * @dev Fallback function to handle calls to the contract.
     * This function is used to handle calls to the contract that do not match any function signature.
     */
    fallback() external payable {
        // Placeholder for fallback logic
        // This function can be used to handle calls to the contract that do not match any function
        // signature. It can be used for handling unexpected calls or for other purposes.
        emit RampDeposit(address(0), msg.value, msg.sender);
    }

    /**
     * @dev Function to check if an asset is allowed.
     * @param asset The address of the asset to be checked.
     * @return bool Returns true if the asset is allowed, false otherwise.
     */
    function isAssetAllowed(address asset) external view returns (bool) {
        return _allowedAssets[asset];
    }

    /**
     * @dev Function to get the list of allowed assets.
     * @return address[] Returns an array of addresses of allowed assets.
     */
    function getAllowedAssets() external view returns (address[] memory) {
        return _allowedAssetsList;
    }

    /**
     * @dev Function to set a new vault address.
     * @param _vault The address of the new vault.
     * @notice This function can only be called by the owner of the contract.
     */
    function setNewVault(address payable _vault) external onlyOwner {
        // Ensure the vault address is valid and not the zero address or the current vault
        if (_vault == address(0) || _vault == vault) {
            revert Invalid__VaultAddress(_vault);
        }
        // Set the vault address where the project revenue is stored
        vault = _vault;
        emit VaultChanged(vault, _vault);
    }
}
