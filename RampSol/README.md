## RampSol Architecture

RampSol contains the Solidity implementation of the SnappiPay on/off-ramp. Contracts are built with the OpenZeppelin upgradeable stack and deployed through Foundry automation for both Ethereum-compatible networks and Hedera.

### Directory Layout
- `src/` – Core protocol contracts (`RampContract.sol`, `IRampContract.sol`) and helper libraries.
- `script/` – Foundry scripts used for deployment, upgrades, and operational tasks (minting, token deployment).
- `run/` & `deploy/` – Shell wrappers that parameterise the scripts for specific networks.
- `broadcast/` – Transaction traces generated by `forge script` when broadcasting to chains.
- `test/` – Forge unit and integration tests.

### Core Contracts
**`RampContract.sol`**  
The primary upgradeable contract. It inherits:
- `Initializable` – to support proxy deployments.
- `PausableUpgradeable` & `OwnableUpgradeable` – to gate mutability behind the controller address.
- `ReentrancyGuardTransient` – to block re-entrancy across state-changing entry points.

**`IRampContract.sol`**  
Interface used by external callers, script tooling, and cross-chain documentation. It declares:
- `AssetInfo` struct (`feePercentage`, `revenuePerAsset`).
- `PermitParams` struct for EIP-2612 flows.
- Events that standardise observability across chains.
- Enumerations for `OnrampMedium` and `Region` so off-chain settlement can infer fiat rails.

**`helpers/errors.sol`**  
Custom error types that keep revert payloads compact and expressive (`Asset__InvalidAddress`, `Invalid__FeePercentage`, etc.).

### Storage Model
`RampContract` keeps a clear separation between customer liquidity and protocol revenue:
- `_allowedAssets` / `_allowedAssetsList` – fast membership checks plus enumeration when discovering allowed ERC-20s.
- `assetInfo` – maps token address → `AssetInfo` with current fee tier and accumulated revenue.
- `vault` – payable address that receives revenue withdrawals.
- `nativeAsset` – symbol/name used when emitting events for the chain’s native currency.

All ERC-20 interactions rely on OpenZeppelin interfaces (`IERC20`, `IERC20Metadata`, `IERC20Permit`).

### Lifecycle & Workflows
1. **Initialization**  
   `initialize(controller, vault, nativeAsset)` seeds ownership, default native asset entry, and marks ETH/GLMR/etc. (`address(0)`) as an allowed asset with zero revenue.

2. **Asset Governance**  
   - `addAllowedAsset` pulls an optional seed allowance from a funder account, sets the fee percentage (1–5%), and emits `AssetAllowedAdded`.
   - `removeAllowedAsset` unwinds the allow-list entry, transfers residual balances to a chosen recipient, and emits `AssetAllowedRemoved`.
   - `setNewFeePercentage` and `setNewVault` allow controlled reconfiguration.

3. **Deposits (Off-Ramp Intake)**  
   - `offRampDeposit` accepts ERC-20 transfers, computes protocol fees with `Math.mulDiv`, persists revenue, and emits `RampDeposit`.
   - `offRampNative` mirrors the flow for `msg.value` deposits.
   - `offRampWithPermit` performs the same operation but first calls `permit` to authorise the transfer in a single UX-friendly transaction.

4. **Withdrawals (On-Ramp Delivery)**  
   `onRampWithdraw` and `onRampNative` send tokens/native currency to customers. They enforce that operational liquidity cannot dip below accumulated revenue.

5. **Revenue Extraction**  
   - `withdrawAssetRevenue` transfers the accumulated fee balance for a particular ERC-20 to the `vault`.
   - `withdrawEtherRevenue` handles revenue accrued in the native asset.

6. **Pausable Safety Switch**  
   `pause`/`unpause` can be triggered by the controller to freeze or resume state transitions during incidents or upgrades.

### Events & Observability
Key events defined in `IRampContract`:
- `AssetAllowedAdded`, `AssetAllowedRemoved`
- `RampDeposit`, `RampWithdraw`
- `EthReceived`, `EthWithdrawn`
- `AssetRevenueWithdrawn`, `VaultChanged`

Scripts, indexers, and analytic pipelines rely on these for cross-chain reconciliation.

### Security Considerations
- **Reentrancy**: All mutating entry points that move value are guarded via `nonReentrant`.
- **Access Control**: `onlyOwner` gates configuration and withdrawal routes; owner is set during initialization and can be upgraded through the proxy admin.
- **Input Validation**: Helper errors ensure addresses and fees are sane (`feePercentage` must be within 1–5%). Underflow/overflow is prevented through OpenZeppelin `Math` helpers which revert on unsafe arithmetic.
- **Revenue Separation**: Withdrawals check that funds minus `revenuePerAsset` remain sufficient before transferring customer liquidity.
- **Upgrade Hygiene**: Because the contract is intended for proxy deployment, storage layout changes must preserve variable ordering. New state variables should append to the existing layout.

### Tooling & Testing
- Run `forge build` or `forge test` from this directory to compile and execute the Forge-based test suite in `test/`.
- Gas profiling (`forge snapshot`) is useful to monitor upgrades.
- The `script/` folder includes flows for deploying core contracts, minting example tokens, and performing on/off-ramp operations. Results are stored under `broadcast/` for auditability.

### Deployment Flow
Typical deployment steps:
1. Deploy upgradeable proxy + implementation using `script/01_Deploy.s.sol`.
2. Optionally deploy the Hedera-specific bridge contracts with `script/03_DeployRampHedera.sol`.
3. Seed the ramp with assets via `run/add_asset_sepolia.sh` (or the Hedera equivalents).
4. Verify the deployed implementation with `deploy/verify.sh` if the target network supports it.

### Integration Checklist
- Off-chain services must map `OnrampMedium` and `Region` enumerations to fiat rails.
- Client applications invoking `offRampWithPermit` should populate `PermitParams` following ERC-2612 conventions.
- Monitoring should subscribe to `RampDeposit`/`RampWithdraw` events to reconcile off-chain ledgers with protocol state.
